---
date: 2019-06-12
title: "Intermittent demand, Croston and Die Hard"
tags: [R]
menu:
  main:
    parent: Blog
    identifier: /blog/intermittent
    weight: 1
---

<div style="text-align:center;">
  <a href="https://en.wikipedia.org/wiki/List_of_Christmas_films">
    <img src="/img/diehard.jpg" title = "Die Hard is the best Christmas movie" width="600" height="400"></a>
</div>


I have recently been confronted to a kind of data set and problem that I was not even aware existed:
intermittent demand data. Intermittent demand arises when the demand for a certain good arrives
sporadically. Let's take a look at an example, by analyzing the number of downloads for the `{RDieHarder}`
package:

```{r, include = FALSE}
library(tidyverse)
library(tsintermittent)
library(nnfor)
library(cranlogs)
library(brotools)
```

```{r, eval = FALSE}
library(tidyverse)
library(tsintermittent)
library(nnfor)
library(cranlogs)
library(brotools)
```

```{r}
rdieharder <- cran_downloads("RDieHarder", from = "2017-01-01")

ggplot(rdieharder) +
  geom_line(aes(y = count, x = date), colour = "#82518c") +
  theme_blog()
```

Let's take a look at just one month of data, because the above plot is not very clear, because of
the outlier just before 2019... I wonder now, was that on Christmas day?

```{r}
rdieharder %>%
  filter(count == max(count))
```

Not exactly on Christmas day, but almost! Anyways, let's look at one month of data:

```{r}
january_2018 <- rdieharder %>%
  filter(between(date, as.Date("2018-01-01"), as.Date("2018-02-01")))

ggplot(january_2018) +
  geom_line(aes(y = count, x = date), colour = "#82518c") +
  theme_blog()
```

Now, it is clear that this will be tricky to forecast. There is no discernible pattern,
no trend, no seasonality... nothing that would make it "easy" for a model to learn how to forecast
such data.

This is typical intermittent demand data. Specific methods have been developed to forecast such
data, the most well-known being Croston, as detailed in 
[this paper](https://www.jstor.org/stable/3007885?seq=1#page_scan_tab_contents). 
A function to estimate such models is available in the `{tsintermittent}` package, written by
[Nikolaos Kourentzes](https://kourentzes.com/forecasting/2014/06/23/intermittent-demand-forecasting-package-for-r/)
who also wrote another package, `{nnfor}`, which uses Neural Networks to forecast time series data.
I am going to use both to try to forecast the intermittent demand for the `{RDieHarder}` package
for the year 2019.

Let's first load these packages:

```{r, include = FALSE}
library(tsintermittent)
library(nnfor)
```

```{r, eval = FALSE}
library(tsintermittent)
library(nnfor)
```

And as usual, split the data into training and testing sets:

```{r}
train_data <- rdieharder %>%
  filter(date < as.Date("2019-01-01")) %>%
  pull(count) %>%
  ts()

test_data <- rdieharder %>%
  filter(date >= as.Date("2019-01-01"))
```

Let's consider three models; a naive one, which simply uses the mean of the training set as the 
forecast for all future periods, Croston's method, and finally a Neural Network from the `{nnfor}`
package:

```{r}
naive_model <- mean(train_data)

croston_model <- crost(train_data, h = 163)

nn_model <- mlp(train_data, reps = 1, hd.auto.type = "cv")

nn_model_forecast <- forecast(nn_model, h = 163)
```

The `crost()` function estimates Croston's model, and the `h` argument produces the 
forecast for the next 163 days. `mlp()` trains a multilayer perceptron, and the `hd.auto.type = "cv"`
argument means that 5-fold cross-validation will be used to find the best number of hidden nodes. I
then obtain the forecast using the `forecast()` function.

In order to rank the models, I follow [this paper](https://www.sciencedirect.com/science/article/pii/S0169207006000239)
from Rob J. Hyndman, who wrote a very useful book titled [Forecasting: Principles and Practice](https://otexts.com/fpp2/),
and use the Mean Absolute Scaled Error, or MASE. You can also read [this shorter pdf](https://robjhyndman.com/papers/foresight.pdf)
which also details how to use MASE to measure the accuracy for intermittent demand. Here is the
function:

```{r}
mase <- function(train_ts, test_ts, outsample_forecast){

  naive_insample_forecast <- stats::lag(train_ts)

  insample_mae <- mean(abs(train_ts - naive_insample_forecast), na.rm = TRUE)
  error_outsample <- test_ts - outsample_forecast

  ase <- error_outsample / insample_mae
  mean(abs(ase), na.rm = TRUE)
}
```

It is now easy to compute the models' accuracies:

```{r}
mase(train_data, test_data$count, naive_model)
mase(train_data, test_data$count, croston_model$component$c.out[1])
mase(train_data, test_data$count, nn_model_forecast$mean)
```

Croston's method is the one that performs best from the three. Maybe surprisingly, the naive method
performs just as well as the Neural Network! Let's also plot the predictions
with the true values from the test set:

```{r}
test_data <- test_data %>%
  mutate(naive_model_forecast = naive_model,
         croston_model_forecast = croston_model$component$c.out[1],
         nn_model_forecast = nn_model_forecast$mean) %>%
  select(-package) %>%
  rename(actual_value = count)


test_data_longer <- test_data %>%
  gather(models, value,
         actual_value, naive_model_forecast, croston_model_forecast, nn_model_forecast)
```

```{r}
ggplot(test_data_longer) +
  geom_line(aes(y = value, x = date, colour = models)) +
  theme_blog()
```

Just to make sure I didn't make a mistake when writing the `mase()` function, let's use the 
`accuracy()` function from the `{forecast}` package and compare the result for the Neural Network:

```{r}
library(forecast)
accuracy(nn_model_forecast, x = test_data$actual_value)
```

The result is the same, so it does seem like the naive method is not that bad, actually! Now, in
general, intermittent demand series have a lot of 0 values, which is not really the case here. I 
still think that the methodology fits to this particular data set.

How else would you have forecast this data? Let me know via twitter!


Hope you enjoyed! If you found this blog post useful, you might want to follow 
me on [twitter](https://www.twitter.com/brodriguesco) for blog post updates and 
[buy me an espresso](https://www.buymeacoffee.com/brodriguesco) or [paypal.me](https://www.paypal.me/brodriguesco).

<style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/brodriguesco"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me an Espresso"><span style="margin-left:5px">Buy me an Espresso</span></a>
